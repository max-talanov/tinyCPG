# -*- coding: utf-8 -*-
"""2_stdp_Izhi_brian2_memCPG.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10Pa4l8ths6eCLZ-ojkYfHCkU1BU0-8qg

# Install and import
"""

!pip install brian2

from brian2 import *

"""# Defs

## Functions
"""

def generate_Izhi_neurons(neurons_n):
  neurons = NeuronGroup(neurons_n,
                        '''dv/dt = (ge * (Ee-vr) + El - v) / taum : volt
                        dge/dt = -ge / taue : 1''',
                        threshold='v>vt', reset='v = vr',
                        method='exact')
  return neurons

def generate_STDP_DA_synapses(pre, post):
  """
    Generates the STDP modulated with DA synapses
    pre -- the presynaptic neurons
    post -- the postsynaptic neurons
    mode is external variable: mode = 0 switches off DA modulation, mode = 1 switches on DA modulation.
    """
  synapse_stdp = Synapses(pre, post,
                          model='''mode: 1
                          dc/dt = -c / tauc : 1 (clock-driven)
                          dd/dt = -d / taud : 1 (clock-driven)
                          ds/dt = mode * c * d / taus : 1 (clock-driven)
                          dApre/dt = -Apre / taupre : 1 (event-driven)
                          dApost/dt = -Apost / taupost : 1 (event-driven)''',
                          on_pre='''ge += s
                          Apre += dApre
                          c = clip(c + mode * Apost, -gmax, gmax)
                          s = clip(s + (1-mode) * Apost, -gmax, gmax)
                          ''',
                          on_post='''Apost += dApost
                          c = clip(c + mode * Apre, -gmax, gmax)
                          s = clip(s + (1-mode) * Apre, -gmax, gmax)
                          ''',
                          method='euler'
                          )
  return synapse_stdp

def generate_simple_synapses(pre, post):
  synapse = Synapses(pre, post, model='''s: volt''', on_pre='v += s')
  return synapse

"""## Parameters"""

# Parameters
simulation_duration = 1000 ## ms
simulation_hill_toe_phases_num = 4

conn_probability = 0.002 ## 0.02
cut2rg_conn_probability = 0.002
cut2rg_stdp_w = 0.001
rg2motor_conn_probability = 0.02
rg2motor_stdp_w = 0.001
stdp_synapse_probability = 0.5

cut_fibers_num = 100
cut_fibers_freq = 200*Hz

bs_fibers_num = 100
bs_fibers_freq = 200*Hz

rg_num = 200
motor_num = 200

## Neurons
taum = 10*ms
Ee = 0*mV
vt = -54*mV
vr = -60*mV
El = -74*mV
taue = 5*ms

## STDP
taupre = 20*ms
taupost = taupre
gmax = .01
dApre = .01
dApost = -dApre * taupre / taupost * 1.05
dApost *= gmax
dApre *= gmax

## Dopamine signaling
tauc = 1000*ms
taud = 200*ms
taus = 1*ms
epsilon_dopa = 5e-3

"""# Network setup
![](https://www.frontiersin.org/files/Articles/1124950/fnins-17-1124950-HTML/image_m/fnins-17-1124950-g001.jpg)

## Simulation parameters
"""

# Setting the stage
start_scope()

#Cutaneous inputs
poisson_cut_input = PoissonGroup(cut_fibers_num, rates=cut_fibers_freq)
cut_monitor = SpikeMonitor(poisson_cut_input)

#BS inputs
bs_poisson_cut_input = PoissonGroup(bs_fibers_num, rates=bs_fibers_freq)
bs_cut_monitor = SpikeMonitor(bs_poisson_cut_input)

# Rythm generators
rg_neurons = generate_Izhi_neurons(rg_num)
rg_neurons.v = vr
rg_neurons_monitor = SpikeMonitor(rg_neurons)
rg_neurons_voltages = StateMonitor(rg_neurons, 'v', record=[10,rg_num-10])

# Motor neurons
motor_neurons = generate_Izhi_neurons(motor_num)
motor_neurons.v = vr
motor_neurons_monitor = SpikeMonitor(motor_neurons)
motor_neurons_voltages = StateMonitor(motor_neurons, 'v', record=[10,motor_num-10])

## synapse = generate_simple_synapses(spike_input, neurons)
cut2rg = generate_simple_synapses(poisson_cut_input, rg_neurons)
## synapse.connect(i=[0, 1], j=[0, 1])
## cut2rg.connect(i=[0, 1], j=[0, 1])
cut2rg.connect(p=cut2rg_conn_probability) ## TODO possibly increase
cut2rg.s = 100. * mV

rg2motor = generate_simple_synapses(rg_neurons, motor_neurons)
## p=0.01
rg2motor.connect(p=rg2motor_conn_probability) ## TODO possibly increase
rg2motor.s = 100. * mV

## STDP cut -> rg
synapse_stdp = generate_STDP_DA_synapses(poisson_cut_input, rg_neurons)
synapse_stdp.connect(p=stdp_synapse_probability)
synapse_stdp.mode = 0
synapse_stdp.s = cut2rg_stdp_w # default weight
synapse_stdp.c = 1e-10
synapse_stdp.d = 0
## record=[0, 5, 10]
synapse_stdp_monitor = StateMonitor(synapse_stdp, ['s', 'c', 'd'], record=True)


## STDP bs -> rg
bs_synapse_stdp = generate_STDP_DA_synapses(bs_poisson_cut_input, rg_neurons)
bs_synapse_stdp.connect(p=stdp_synapse_probability)
bs_synapse_stdp.mode = 0
bs_synapse_stdp.s = cut2rg_stdp_w # default weight
bs_synapse_stdp.c = 1e-10
bs_synapse_stdp.d = 0
## record=[0, 5, 10]
bs2rg_stdp_monitor = StateMonitor(synapse_stdp, ['s', 'c', 'd'], record=True)

## STDP rg -> motor
rg2motor_stdp = generate_STDP_DA_synapses(rg_neurons, motor_neurons)
rg2motor_stdp.connect(p=stdp_synapse_probability)
rg2motor_stdp.mode = 0
rg2motor_stdp.s = rg2motor_stdp_w #default weight
rg2motor_stdp.c = 1e-10
rg2motor_stdp.d = 0
## record=[0, 5, 10]
rg2motor_stdp_monitor = StateMonitor(rg2motor_stdp, ['s', 'c', 'd'], record=True)

synapse_stdp

"""# Run"""

# Simulation
## Classical STDP
#synapse_stdp.mode = 0
## The complete simulation
## run(simulation_duration, report='text')

## Split simulation in N chanks and switch on sequentally
for l in range(simulation_hill_toe_phases_num):
    n = len(poisson_cut_input)
    chank = int(n/simulation_hill_toe_phases_num)
    dur = int(simulation_duration/simulation_hill_toe_phases_num)
    poisson_cut_input[:].rates = 0*Hz
    poisson_cut_input[l*chank:(l+1)*chank-1].rates = 200*Hz
    ## print (str(l*chank) + ": " + str((l+1)*chank-1))
    ## print (poisson_cut_input)
    ## print (dur)
    run(dur*ms, report='text')

"""# Visualisation"""

# Visualisation
cut_indices, cut_times = cut_monitor.it
rg_indices, rg_times = rg_neurons_monitor.it
motor_indices, motor_times = motor_neurons_monitor.it
render_duration = 1000 * ms ## Update if you want to scale figures
len(cut_times)

"""## Weights and voltages: RG ⇒ Motor"""

figure(figsize=(20, 10))

subplot(411)
plot(synapse_stdp_monitor.t/second, synapse_stdp_monitor.s.T/gmax, '-')
xlim([0, render_duration/second])
ylabel('Synaptic\nstrength s(t)')
xlabel('Time (s)')

subplot(412)
plot(rg2motor_stdp_monitor.t/second, rg2motor_stdp_monitor.s.T/gmax, '-')
xlim([0, render_duration/second])
ylabel('Synaptic\nstrength s(t)')
xlabel('Time (s)')


#subplot(413)
#plot(rg_neurons_voltages.t/second, rg_neurons_voltages[10].v/mV)
#plot(rg_neurons_voltages.t/second, rg_neurons_voltages[rg_num-10].v/mV)
#xlim([0, render_duration/second])
#tight_layout()

#subplot(414)
#plot(motor_neurons_voltages.t/second, motor_neurons_voltages[10].v/mV)
#plot(motor_neurons_voltages.t/second, motor_neurons_voltages[motor_num-10].v/mV)
#xlim([0, render_duration/second])
#tight_layout()

show()

"""## Spiketimes cut ⇒ RG"""

figure(figsize=(20, 10))

subplot(411)
plot(cut_times, cut_indices, 'b|')
xlim([0, render_duration/second])
ylim([-0.5, cut_fibers_num])
xticks([])

subplot(412)
plot(rg_times, rg_indices, 'g|')
xlim([0, render_duration/second])
ylim([-0.5, rg_num])
xlabel('Time (s)')

subplot(413)
plot(motor_times, motor_indices, 'r|')
xlim([0, render_duration/second])
ylim([-0.5, motor_num])
xlabel('Time (s)')


show()